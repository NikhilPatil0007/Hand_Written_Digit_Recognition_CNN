# -*- coding: utf-8 -*-
"""Hand_Written_Digit_Recognition_CNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BiGFtDgcoRg7hTpIcO7yy7ntdhHJthKw
"""

import tensorflow as tf
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.utils import to_categorical
import numpy as np
import struct
import pandas as pd

# Load and preprocess the MNIST dataset
def load_mnist_images(filename):
    # Open the file in read-binary mode
    with open(filename, 'rb') as f:
        # Read the magic number and dimensions
        magic, num_images, rows, cols = struct.unpack(">IIII", f.read(16))
        # Load the images and normalize the pixel values to [0, 1]
        images = np.fromfile(f, dtype=np.uint8).reshape(num_images, rows, cols) / 255.0
    return images

def load_mnist_labels(filename):
    # Open the file in read-binary mode
    with open(filename, 'rb') as f:
        # Read the magic number and number of labels
        magic, num_labels = struct.unpack(">II", f.read(8))
        # Load the labels
        labels = np.fromfile(f, dtype=np.uint8)
    return labels

# Load images and labels (use the correct filenames here)
X_train = load_mnist_images('train-images.idx3-ubyte')
y_train = load_mnist_labels('train-labels.idx1-ubyte')
X_test = load_mnist_images('t10k-images.idx3-ubyte')
y_test = load_mnist_labels('t10k-labels.idx1-ubyte')

# Convert labels to one-hot encoding
y_train = tf.keras.utils.to_categorical(y_train, 10)
y_test = tf.keras.utils.to_categorical(y_test, 10)

print(f'Training data shape: {X_train.shape}')
print(f'Training labels shape: {y_train.shape}')
print(f'Test data shape: {X_test.shape}')
print(f'Test labels shape: {y_test.shape}')

# Define the CNN model
model = Sequential([
    Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(28, 28, 1)),
    MaxPooling2D(pool_size=(2, 2)),
    Dropout(0.25),

    Conv2D(64, kernel_size=(3, 3), activation='relu'),
    MaxPooling2D(pool_size=(2, 2)),
    Dropout(0.25),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(10, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(X_train, y_train, batch_size=128, epochs=10, validation_split=0.1)

# Evaluate the model
test_loss, test_accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f'Test accuracy: {test_accuracy:.4f}')

import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# Load your trained model (if not already loaded)
# model = load_model('path_to_your_trained_model.h5')

# Load the image you want to test (for example, an MNIST image)
img_path = '/content/final-image (1).jpg'  # Replace with your image path
img = image.load_img(img_path, target_size=(28, 28), color_mode='grayscale')

# Preprocess the image: Convert to numpy array and normalize
img_array = image.img_to_array(img) / 255.0  # Normalize if your model was trained with normalized data
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension

# Predict using the trained model
predictions = model.predict(img_array)

# Get the predicted class label (e.g., for MNIST, it will be a number between 0 and 9)
predicted_class = np.argmax(predictions, axis=1)

# Print the predicted class
print(f'Predicted label: {predicted_class[0]}')

# Plot the image to see it
plt.imshow(img, cmap='gray')
plt.title(f'Predicted label: {predicted_class[0]}')
plt.show()